# 设计模式原则

- [Open Close Principle](#OCP) 开闭原则
- [Dependence Inversion Principle](#DIP) 依赖倒置原则
- [Single Responsibility Principle](#SRP) 单一职责原则
- [Law of Demeter](#LoD) 迪米特法则 <sub>[Least Knowledge Principle](#LKP) 最少知道原则</sub>
- [Liskov Substitution Principle](#LSP) 里氏替换原则
- [Interface Segregation Principle](#ISP) 接口隔离原则

---

> **`OCP`是最基础的一个原则，其余原则是`OCP`的具体形态**

🚦[home](index.md#java)

## OCP

> `OCP`是最基础的一个原则，其余原则是`OCP`的具体形态
> - `OCP`可以提高复用性
> - `OCP`可以提高可维护性
> - `OCP`是面向对象开发的要求
> - `OCP`对测试影响很大
>
> `Open Close Principle`.Software entities like classes,modules and functions should be open for extension<sub>扩展</sub> but closed for modifications<sub>修改</sub>
>
> 一个软件实体应该通过**扩展**来实现变化，而不是通过修改已有的代码来实现变化
>
> 变化
> > 逻辑变化
> > > 只变化一个逻辑，而不涉及其他模块。比如原有的一个算法是`a*b+c`，现在需要修改为`a*b*c`，可以通过修改原有类中的方法来完成，前提条件是所有依赖或关联类都按照相同的逻辑处理。
> >
> > 子模块变化
> > > 一个模块变化，会对其他的模块产生影响，特别是**低层次**的模块变化**必然**引起**高层**模块的变化。因此在通过**扩展**完成变化时，高层次的模块修改是必然的。
> >
> > 可见视图变化
> > > 可见视图是提供给客户使用的界面，如**JSP程序**、**Swing界面**等，该部分的变化一般会引起**连锁反应**（特别是在国内做项目，做欧美的外包项目一般不会影响太大）。如果仅仅是界面上**按钮**、**文字的重新排布**倒是简单；最司空见惯的是**业务耦合变化**：一个展示数据的列表，按照原有的需求是6列，突然有一天要增加1列，而且这一列要跨N张表，处理M个逻辑才能展现出来，这样的变化是比较恐怖的，但还是可以通过扩展来完成变化，这就要看原有的设计是否灵活。
>
> 注意
> > 在设计时尽量适应一些变化，以提高项目的稳定性和灵活性，真正实现**拥抱变化**\
> > 开闭原则对扩展开放，对修改关闭。并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段\
> > 一个项目的基本路径应该是这样的：**项目开发、重构、测试、投产、运维**，其中的**重构**可以对原有的设计和代码进行修改，**运维**尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性
>
> 如何使用
> > **抽象约束**
> > > 抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过**接口**或**抽象类**可以约束一组可能变化的行为，并且能够实现对扩展开放。
> > 1. 通过**接口**或**抽象类**约束扩展，对扩展进行**边界限定**，不允许扩展出现在**接口**或**抽象类**中的`public`方法
> > 2. **参数类型、引用对象**尽量使用**接口**或**抽象类**，而不是实现类
> > 3. 抽象层尽量保持稳定，一旦确定即不允许修改
> >
> > 使用`metadata`<sub>元数据。即配置参数，用来描述环境和数据的数据，可以从文件、数据库中获得</sub>控制**模块行为**
> > > 尽量使用`metadata`来控制程序的行为，减少重复开发
> >
> > 制定项目章程。即**约定优于配置**
> >
> > **封装变化**
> > > 封装可能发生的变化，即是`protected variations`<sub>受保护的变化</sub>。找出预计有变化或不稳定的点，为这些变化点创建稳定的接口，一旦预测到或“第六感”发觉有变化，就可以进行封装，23种设计模式即是从各个不同的角度对变化进行封装。
> > 1. 将相同的变化封装到一个接口或抽象类中；
> > 2. 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。

[top](#设计模式原则) 🚦[home](index.md#java)

## DIP

> `Dependence Inversion Principle`<sub>依赖倒置原则</sub>
>
> High level modules should not depend upon low level modules.Both should depend upon abstractions.<sub>高层模块不应该依赖低层模块，两者都应该依赖其抽象</sub>
>
> Abstractions should not depend upon details.<sub>抽象不应该依赖细节</sub>
>
> Details should depend upon abstractions.<sub>细节应该依赖抽象</sub>
>
> **JAVA中的表现**
> - `Object-Oriented Design`<sub> `OOD` 面向对象设计</sub>
> - 模块间的依赖通过抽象发生
> - 实现类之间不发生直接的依赖关系
> - 其依赖关系是通过接口或抽象类产生的
> - 接口或抽象类不依赖于实现类
> - 实现类依赖接口或抽象类
>
> **好处**
> - 减少类间的耦合性
> - 提高系统的稳定性<sub>固化的、健壮的才是稳定的</sub>
> - 降低并行开发引起的风险
> - 提高代码的可读性和可维护性
>
> **依赖三种写法**
> 1. **构造函数**传递依赖对象
> 2. `Setter`方法传递依赖对象
> 3. **接口注入**<sub>接口声明依赖对象</sub>
>
> **注意**
> > 稳定性<sub>固化的、健壮的才是稳定的</sub>较高的设计，在周围环境频繁变化的时候，依然可以做到“我自岿然不动” \
> > 在`Java`中，只要定义变量就必然要有类型，一个变量可以有两种类型：`表面类型`和`实际类型`
> > > `表面类型`：是在定义的时候赋予的类型 \
> > > `实际类型`：是对象的类型(具体类型new xxx()) \
> >
> > `TDD`<sub>`Test Driven Development` 测试驱动开发</sub>模式就是依赖倒置原则的最高级应用
> >
> > **倒置**
> > > 依赖正置就是类间的依赖是实实在在的**实现类**间的依赖，也就是**面向实现编程**，这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑 \
> > > 而编写程序需要的是对现实世界事物进行抽象，抽象的结果就是有了**抽象类和接口**，然后根据系统设计的需要产生抽象间的依赖，代替人们传统思维中事物间的依赖，**倒置**就来自于此。
>
> **最佳实践**
> - 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合
> - 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
> - 变量的表面类型尽量是接口或者是抽象类
> - 任何类都不应该从具体类派生
> - 尽量不要覆写基类的方法
> >
> > 结合[LSP](#lsp)<sub>里氏替换原则</sub>使用
> > - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系
> > - 抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化

[top](#设计模式原则) 🚦[home](index.md#java)

## SRP

> Single Responsibility Principle<sub>单一职责原则</sub>
>
> There should never be more than one reason for a class to change.<sub>应该有且仅有一个原因引起类的变更</sub>
>
> 好处
> - 类的复杂性降低，实现什么职责都有清晰明确的定义
> - 可读性提高
> - 可维护性提高
>
> 名词
> - `BO`<sub>业务对象 `Business Object`</sub>
> - `Biz`<sub>业务逻辑 `Business Logic`</sub>
> - `VO`<sub>值对象 `Value Object`</sub>
>
> 注意
> > 单一职责原则提出了一个编写程序的标准，用**职责**或**变化原因**来衡量接口或类设计得是否优良。但是**职责**和**变化原因**都是不可度量的，因项目而异，因环境而异\
> > 接口一定要做到单一职责\
> > 类的设计尽量做到只有一个原因引起变化

[top](#设计模式原则) 🚦[home](index.md#java)

## ISP

> `Interface Segregation Principle`<sub>接口隔离原则</sub>
>
> Clients should not be forced to depend upon interfaces that they don't use.<sub>客户端不应该依赖它不需要的接口</sub>
>
> The dependency of one class to another one should depend on the smallest possible interface.<sub>类间的依赖关系应该建立在最小的接口上</sub>
>
> 注意
> > 接口尽量细化，同时接口中的方法尽量少\
> > **单一职责**要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；而接口隔离原则要求接口的方法尽量少
>
> 规范约束
> > 接口要尽量小
> > > 不出现`Fat Interface`<sub>臃肿的接口</sub>\
> > > 根据接口隔离原则拆分接口时，首先必须满足**单一职责原则**
> >
> > 接口要**高内聚**
> > > 高内聚就是提高接口、类、模块的处理能力，减少对外的交互\
> > > 不讲任何条件、立刻完成任务的行为就是高内聚的表现\
> > > 要求在接口中尽量少公布`public`方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本
> >
> > 定制服务
> > > 单独为一个个体提供优良的服务\
> > > 做系统设计时需要考虑对系统之间或模块之间的接口采用定制服务\
> > > 只提供访问者需要的方法
> >
> > 接口设计是有限度的
> > > 接口的设计粒度越小，系统越灵活\
> > > 灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，所以接口设计一定要注意适度
>
> 最佳实践
> > 接口隔离原则是对接口的定义，同时也是对类的定义;接口和类尽量使用原子接口或原子类来组装
> >
> > 一个接口只服务于一个子模块或业务逻辑
> > > 通过业务逻辑压缩接口中的public方法，\
> > > 接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；\
> > > 已经被污染了的接口，尽量去修改\
> > > 若变更的风险较大，则采用**适配器模式**进行转化处理；

[top](#设计模式原则) 🚦[home](index.md#java)

## 


[top](#设计模式原则) 🚦[home](index.md#java)

## 


[top](#设计模式原则) 🚦[home](index.md#java)

## 

[top](#设计模式原则) 🚦[home](index.md#java)